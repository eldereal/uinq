/* This file is auto generated by codegen project. Don't modify this file directly */
/* SelectMany for Uniq sources and system mapper */
using System;
using System.Collections.Generic;
namespace Uniq
{
    public static partial class Uniq
    {
        public static Enumerable <SelectManyIndirect<TEnumerable, TEnumerator, TS, T[], ArrayEach<T>, ArrayEach<T>.Enumerator, T>, SelectManyIndirect<TEnumerable, TEnumerator, TS, T[], ArrayEach<T>, ArrayEach<T>.Enumerator, T>. Enumerator, T> SelectMany<TEnumerable, TEnumerator, TS, T>( this Enumerable<TEnumerable, TEnumerator, TS> source, Func<TS, T[]> mapper) where TEnumerable : struct, IEnumerable<TEnumerator, TS> where TEnumerator : struct, IEnumerator<TS> { Func<T[], Enumerable<ArrayEach<T>, ArrayEach<T>.Enumerator, T>> mapper2; if (Static<Func<T[], Enumerable<ArrayEach<T>, ArrayEach<T>.Enumerator, T>>>.instance == null) { mapper2 = m => m.Each(); Static<Func<T[], Enumerable<ArrayEach<T>, ArrayEach<T>.Enumerator, T>>>.instance = mapper2; } else { mapper2 = Static<Func<T[], Enumerable<ArrayEach<T>, ArrayEach<T>.Enumerator, T>>>.instance; } return new Enumerable <SelectManyIndirect<TEnumerable, TEnumerator, TS, T[], ArrayEach<T>, ArrayEach<T>.Enumerator, T>, SelectManyIndirect <TEnumerable, TEnumerator, TS, T[], ArrayEach<T>, ArrayEach<T>.Enumerator, T>.Enumerator, T>( new SelectManyIndirect <TEnumerable, TEnumerator, TS, T[], ArrayEach<T>, ArrayEach<T>.Enumerator, T>(source.Inner, mapper, mapper2)); }
        public static Enumerable <SelectManyIndirect<TEnumerable, TEnumerator, TS, List<T>, ListEach<T>, ListEach<T>.Enumerator, T>, SelectManyIndirect<TEnumerable, TEnumerator, TS, List<T>, ListEach<T>, ListEach<T>.Enumerator, T>. Enumerator, T> SelectMany<TEnumerable, TEnumerator, TS, T>( this Enumerable<TEnumerable, TEnumerator, TS> source, Func<TS, List<T>> mapper) where TEnumerable : struct, IEnumerable<TEnumerator, TS> where TEnumerator : struct, IEnumerator<TS> { Func<List<T>, Enumerable<ListEach<T>, ListEach<T>.Enumerator, T>> mapper2; if (Static<Func<List<T>, Enumerable<ListEach<T>, ListEach<T>.Enumerator, T>>>.instance == null) { mapper2 = m => m.Each(); Static<Func<List<T>, Enumerable<ListEach<T>, ListEach<T>.Enumerator, T>>>.instance = mapper2; } else { mapper2 = Static<Func<List<T>, Enumerable<ListEach<T>, ListEach<T>.Enumerator, T>>>.instance; } return new Enumerable <SelectManyIndirect<TEnumerable, TEnumerator, TS, List<T>, ListEach<T>, ListEach<T>.Enumerator, T>, SelectManyIndirect <TEnumerable, TEnumerator, TS, List<T>, ListEach<T>, ListEach<T>.Enumerator, T>.Enumerator, T>( new SelectManyIndirect <TEnumerable, TEnumerator, TS, List<T>, ListEach<T>, ListEach<T>.Enumerator, T>(source.Inner, mapper, mapper2)); }
        public static Enumerable <SelectManyIndirect<TEnumerable, TEnumerator, TS, HashSet<T>, HashSetEach<T>, HashSetEach<T>.Enumerator, T>, SelectManyIndirect<TEnumerable, TEnumerator, TS, HashSet<T>, HashSetEach<T>, HashSetEach<T>.Enumerator, T>. Enumerator, T> SelectMany<TEnumerable, TEnumerator, TS, T>( this Enumerable<TEnumerable, TEnumerator, TS> source, Func<TS, HashSet<T>> mapper) where TEnumerable : struct, IEnumerable<TEnumerator, TS> where TEnumerator : struct, IEnumerator<TS> { Func<HashSet<T>, Enumerable<HashSetEach<T>, HashSetEach<T>.Enumerator, T>> mapper2; if (Static<Func<HashSet<T>, Enumerable<HashSetEach<T>, HashSetEach<T>.Enumerator, T>>>.instance == null) { mapper2 = m => m.Each(); Static<Func<HashSet<T>, Enumerable<HashSetEach<T>, HashSetEach<T>.Enumerator, T>>>.instance = mapper2; } else { mapper2 = Static<Func<HashSet<T>, Enumerable<HashSetEach<T>, HashSetEach<T>.Enumerator, T>>>.instance; } return new Enumerable <SelectManyIndirect<TEnumerable, TEnumerator, TS, HashSet<T>, HashSetEach<T>, HashSetEach<T>.Enumerator, T>, SelectManyIndirect <TEnumerable, TEnumerator, TS, HashSet<T>, HashSetEach<T>, HashSetEach<T>.Enumerator, T>.Enumerator, T>( new SelectManyIndirect <TEnumerable, TEnumerator, TS, HashSet<T>, HashSetEach<T>, HashSetEach<T>.Enumerator, T>(source.Inner, mapper, mapper2)); }
        public static Enumerable <SelectManyIndirect<TEnumerable, TEnumerator, TS, LinkedList<T>, LinkedListEach<T>, LinkedListEach<T>.Enumerator, T>, SelectManyIndirect<TEnumerable, TEnumerator, TS, LinkedList<T>, LinkedListEach<T>, LinkedListEach<T>.Enumerator, T>. Enumerator, T> SelectMany<TEnumerable, TEnumerator, TS, T>( this Enumerable<TEnumerable, TEnumerator, TS> source, Func<TS, LinkedList<T>> mapper) where TEnumerable : struct, IEnumerable<TEnumerator, TS> where TEnumerator : struct, IEnumerator<TS> { Func<LinkedList<T>, Enumerable<LinkedListEach<T>, LinkedListEach<T>.Enumerator, T>> mapper2; if (Static<Func<LinkedList<T>, Enumerable<LinkedListEach<T>, LinkedListEach<T>.Enumerator, T>>>.instance == null) { mapper2 = m => m.Each(); Static<Func<LinkedList<T>, Enumerable<LinkedListEach<T>, LinkedListEach<T>.Enumerator, T>>>.instance = mapper2; } else { mapper2 = Static<Func<LinkedList<T>, Enumerable<LinkedListEach<T>, LinkedListEach<T>.Enumerator, T>>>.instance; } return new Enumerable <SelectManyIndirect<TEnumerable, TEnumerator, TS, LinkedList<T>, LinkedListEach<T>, LinkedListEach<T>.Enumerator, T>, SelectManyIndirect <TEnumerable, TEnumerator, TS, LinkedList<T>, LinkedListEach<T>, LinkedListEach<T>.Enumerator, T>.Enumerator, T>( new SelectManyIndirect <TEnumerable, TEnumerator, TS, LinkedList<T>, LinkedListEach<T>, LinkedListEach<T>.Enumerator, T>(source.Inner, mapper, mapper2)); }
        public static Enumerable <SelectManyIndirect<TEnumerable, TEnumerator, TS, Stack<T>, StackEach<T>, StackEach<T>.Enumerator, T>, SelectManyIndirect<TEnumerable, TEnumerator, TS, Stack<T>, StackEach<T>, StackEach<T>.Enumerator, T>. Enumerator, T> SelectMany<TEnumerable, TEnumerator, TS, T>( this Enumerable<TEnumerable, TEnumerator, TS> source, Func<TS, Stack<T>> mapper) where TEnumerable : struct, IEnumerable<TEnumerator, TS> where TEnumerator : struct, IEnumerator<TS> { Func<Stack<T>, Enumerable<StackEach<T>, StackEach<T>.Enumerator, T>> mapper2; if (Static<Func<Stack<T>, Enumerable<StackEach<T>, StackEach<T>.Enumerator, T>>>.instance == null) { mapper2 = m => m.Each(); Static<Func<Stack<T>, Enumerable<StackEach<T>, StackEach<T>.Enumerator, T>>>.instance = mapper2; } else { mapper2 = Static<Func<Stack<T>, Enumerable<StackEach<T>, StackEach<T>.Enumerator, T>>>.instance; } return new Enumerable <SelectManyIndirect<TEnumerable, TEnumerator, TS, Stack<T>, StackEach<T>, StackEach<T>.Enumerator, T>, SelectManyIndirect <TEnumerable, TEnumerator, TS, Stack<T>, StackEach<T>, StackEach<T>.Enumerator, T>.Enumerator, T>( new SelectManyIndirect <TEnumerable, TEnumerator, TS, Stack<T>, StackEach<T>, StackEach<T>.Enumerator, T>(source.Inner, mapper, mapper2)); }
        public static Enumerable <SelectManyIndirect<TEnumerable, TEnumerator, TS, Queue<T>, QueueEach<T>, QueueEach<T>.Enumerator, T>, SelectManyIndirect<TEnumerable, TEnumerator, TS, Queue<T>, QueueEach<T>, QueueEach<T>.Enumerator, T>. Enumerator, T> SelectMany<TEnumerable, TEnumerator, TS, T>( this Enumerable<TEnumerable, TEnumerator, TS> source, Func<TS, Queue<T>> mapper) where TEnumerable : struct, IEnumerable<TEnumerator, TS> where TEnumerator : struct, IEnumerator<TS> { Func<Queue<T>, Enumerable<QueueEach<T>, QueueEach<T>.Enumerator, T>> mapper2; if (Static<Func<Queue<T>, Enumerable<QueueEach<T>, QueueEach<T>.Enumerator, T>>>.instance == null) { mapper2 = m => m.Each(); Static<Func<Queue<T>, Enumerable<QueueEach<T>, QueueEach<T>.Enumerator, T>>>.instance = mapper2; } else { mapper2 = Static<Func<Queue<T>, Enumerable<QueueEach<T>, QueueEach<T>.Enumerator, T>>>.instance; } return new Enumerable <SelectManyIndirect<TEnumerable, TEnumerator, TS, Queue<T>, QueueEach<T>, QueueEach<T>.Enumerator, T>, SelectManyIndirect <TEnumerable, TEnumerator, TS, Queue<T>, QueueEach<T>, QueueEach<T>.Enumerator, T>.Enumerator, T>( new SelectManyIndirect <TEnumerable, TEnumerator, TS, Queue<T>, QueueEach<T>, QueueEach<T>.Enumerator, T>(source.Inner, mapper, mapper2)); }
        public static Enumerable <SelectManyIndirect<TEnumerable, TEnumerator, TS, Dictionary<TK,TV>, DictionaryEach<TK,TV>, DictionaryEach<TK,TV>.Enumerator, KeyValuePair<TK,TV>>, SelectManyIndirect<TEnumerable, TEnumerator, TS, Dictionary<TK,TV>, DictionaryEach<TK,TV>, DictionaryEach<TK,TV>.Enumerator, KeyValuePair<TK,TV>>. Enumerator, KeyValuePair<TK,TV>> SelectMany<TEnumerable, TEnumerator, TS, TK,TV>( this Enumerable<TEnumerable, TEnumerator, TS> source, Func<TS, Dictionary<TK,TV>> mapper) where TEnumerable : struct, IEnumerable<TEnumerator, TS> where TEnumerator : struct, IEnumerator<TS> { Func<Dictionary<TK,TV>, Enumerable<DictionaryEach<TK,TV>, DictionaryEach<TK,TV>.Enumerator, KeyValuePair<TK,TV>>> mapper2; if (Static<Func<Dictionary<TK,TV>, Enumerable<DictionaryEach<TK,TV>, DictionaryEach<TK,TV>.Enumerator, KeyValuePair<TK,TV>>>>.instance == null) { mapper2 = m => m.Each(); Static<Func<Dictionary<TK,TV>, Enumerable<DictionaryEach<TK,TV>, DictionaryEach<TK,TV>.Enumerator, KeyValuePair<TK,TV>>>>.instance = mapper2; } else { mapper2 = Static<Func<Dictionary<TK,TV>, Enumerable<DictionaryEach<TK,TV>, DictionaryEach<TK,TV>.Enumerator, KeyValuePair<TK,TV>>>>.instance; } return new Enumerable <SelectManyIndirect<TEnumerable, TEnumerator, TS, Dictionary<TK,TV>, DictionaryEach<TK,TV>, DictionaryEach<TK,TV>.Enumerator, KeyValuePair<TK,TV>>, SelectManyIndirect <TEnumerable, TEnumerator, TS, Dictionary<TK,TV>, DictionaryEach<TK,TV>, DictionaryEach<TK,TV>.Enumerator, KeyValuePair<TK,TV>>.Enumerator, KeyValuePair<TK,TV>>( new SelectManyIndirect <TEnumerable, TEnumerator, TS, Dictionary<TK,TV>, DictionaryEach<TK,TV>, DictionaryEach<TK,TV>.Enumerator, KeyValuePair<TK,TV>>(source.Inner, mapper, mapper2)); }
        public static Enumerable <SelectManyIndirect<TEnumerable, TEnumerator, TS, SortedDictionary<TK,TV>, SortedDictionaryEach<TK,TV>, SortedDictionaryEach<TK,TV>.Enumerator, KeyValuePair<TK,TV>>, SelectManyIndirect<TEnumerable, TEnumerator, TS, SortedDictionary<TK,TV>, SortedDictionaryEach<TK,TV>, SortedDictionaryEach<TK,TV>.Enumerator, KeyValuePair<TK,TV>>. Enumerator, KeyValuePair<TK,TV>> SelectMany<TEnumerable, TEnumerator, TS, TK,TV>( this Enumerable<TEnumerable, TEnumerator, TS> source, Func<TS, SortedDictionary<TK,TV>> mapper) where TEnumerable : struct, IEnumerable<TEnumerator, TS> where TEnumerator : struct, IEnumerator<TS> { Func<SortedDictionary<TK,TV>, Enumerable<SortedDictionaryEach<TK,TV>, SortedDictionaryEach<TK,TV>.Enumerator, KeyValuePair<TK,TV>>> mapper2; if (Static<Func<SortedDictionary<TK,TV>, Enumerable<SortedDictionaryEach<TK,TV>, SortedDictionaryEach<TK,TV>.Enumerator, KeyValuePair<TK,TV>>>>.instance == null) { mapper2 = m => m.Each(); Static<Func<SortedDictionary<TK,TV>, Enumerable<SortedDictionaryEach<TK,TV>, SortedDictionaryEach<TK,TV>.Enumerator, KeyValuePair<TK,TV>>>>.instance = mapper2; } else { mapper2 = Static<Func<SortedDictionary<TK,TV>, Enumerable<SortedDictionaryEach<TK,TV>, SortedDictionaryEach<TK,TV>.Enumerator, KeyValuePair<TK,TV>>>>.instance; } return new Enumerable <SelectManyIndirect<TEnumerable, TEnumerator, TS, SortedDictionary<TK,TV>, SortedDictionaryEach<TK,TV>, SortedDictionaryEach<TK,TV>.Enumerator, KeyValuePair<TK,TV>>, SelectManyIndirect <TEnumerable, TEnumerator, TS, SortedDictionary<TK,TV>, SortedDictionaryEach<TK,TV>, SortedDictionaryEach<TK,TV>.Enumerator, KeyValuePair<TK,TV>>.Enumerator, KeyValuePair<TK,TV>>( new SelectManyIndirect <TEnumerable, TEnumerator, TS, SortedDictionary<TK,TV>, SortedDictionaryEach<TK,TV>, SortedDictionaryEach<TK,TV>.Enumerator, KeyValuePair<TK,TV>>(source.Inner, mapper, mapper2)); }
        public static Enumerable <SelectManyIndirect<TEnumerable, TEnumerator, TS, IEnumerable<T>, EnumerableEach<T>, EnumerableEach<T>.Enumerator, T>, SelectManyIndirect<TEnumerable, TEnumerator, TS, IEnumerable<T>, EnumerableEach<T>, EnumerableEach<T>.Enumerator, T>. Enumerator, T> SelectMany<TEnumerable, TEnumerator, TS, T>( this Enumerable<TEnumerable, TEnumerator, TS> source, Func<TS, IEnumerable<T>> mapper) where TEnumerable : struct, IEnumerable<TEnumerator, TS> where TEnumerator : struct, IEnumerator<TS> { Func<IEnumerable<T>, Enumerable<EnumerableEach<T>, EnumerableEach<T>.Enumerator, T>> mapper2; if (Static<Func<IEnumerable<T>, Enumerable<EnumerableEach<T>, EnumerableEach<T>.Enumerator, T>>>.instance == null) { mapper2 = m => m.Each(); Static<Func<IEnumerable<T>, Enumerable<EnumerableEach<T>, EnumerableEach<T>.Enumerator, T>>>.instance = mapper2; } else { mapper2 = Static<Func<IEnumerable<T>, Enumerable<EnumerableEach<T>, EnumerableEach<T>.Enumerator, T>>>.instance; } return new Enumerable <SelectManyIndirect<TEnumerable, TEnumerator, TS, IEnumerable<T>, EnumerableEach<T>, EnumerableEach<T>.Enumerator, T>, SelectManyIndirect <TEnumerable, TEnumerator, TS, IEnumerable<T>, EnumerableEach<T>, EnumerableEach<T>.Enumerator, T>.Enumerator, T>( new SelectManyIndirect <TEnumerable, TEnumerator, TS, IEnumerable<T>, EnumerableEach<T>, EnumerableEach<T>.Enumerator, T>(source.Inner, mapper, mapper2)); }
    }
}
